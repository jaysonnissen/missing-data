---
title: "MD_relationships"
author: "Jayson Nissen"
date: "12/18/2017"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library(knitr)
library(ggplot2)
library(cowplot)
library(dplyr)
#library(plyr)
library(kableExtra)

knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE, fig.align = 'center')
options(digits=3)

```


# Purpose
This document aims to ... 


# Relationship between test scores and course grade

This section looks at the relationships between test statistics and student grades using data from three courses collected as part of an earlier study. I combined all of the sections for each of the courses together to get a larger sample for each grade.  

Test statistics include mean, median, and standard deviation. Student grades are defined on a 0-4 (GPA) scale where a 0 represents an F and a 4 represents and A. The first step I took was to create box plots of the test scores for each grade in the available dataset. 


```{r}
load("classes")
df$Course <- as.factor(substr(df$Course, 0, 4))
                       
df2 <- df %>% dplyr::mutate(grad_gpa = as.factor(grad_gpa), 
                    id=1:n()) 

names(df2)[2:4] <- c("Grade", "Pretest", "Posttest")
```

```{r}
df_long <- bind_rows(df2 %>% mutate(test="Posttest", score=Posttest) %>% select(-Pretest, -Posttest) , 
                     df2 %>% mutate(test="Pretest", score=Pretest) %>% select(-Pretest, -Posttest))

ggplot(df_long, aes(x=Grade, y=score)) + geom_boxplot() + 
  scale_y_continuous(name = "Score (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") + 
  facet_grid(test~Course) +  theme_bw() + 
  stat_summary(fun.y="mean", geom="point", size=2, pch=17)
```

For the pretests, there is a very small positive relationship between the median and the grade. In general, as the grade increases the median increases. There is some fluctuation and the relationship is weak, but A students have higher pretests than F students. I will explore this relationship in a little more detail with means and medians. The pretest data also has a lot of outliers that could skew means. These outliers may also be an issue for making the data look similar and are a limitation.

```{r}
course_data <- aggregate(ciprescr~grad_gpa+Course, data=df, FUN = mean)
temp<- aggregate(ciprescr~grad_gpa+Course, data=df, FUN = median)
course_data <- left_join(course_data,temp, by=c("grad_gpa", "Course"))
temp<- aggregate(ciprescr~grad_gpa+Course, data=df, FUN = sd)
course_data <- left_join(course_data,temp, by=c("grad_gpa", "Course"))
temp<- aggregate(ciprescr~grad_gpa+Course, data=df, FUN = IQR)
course_data <- left_join(course_data,temp, by=c("grad_gpa", "Course"))
colnames(course_data)<- c("Grade","Course","Mean_pre","Median_pre","SD_pre","IQR_pre")
course_data$div_iqr_pre <- course_data$IQR/1.35

post_data <- aggregate(cipstscr~grad_gpa+Course, data=df, FUN = mean)
temp<- aggregate(cipstscr~grad_gpa+Course, data=df, FUN = median)
post_data <- left_join(post_data,temp, by=c("grad_gpa", "Course"))
temp<- aggregate(cipstscr~grad_gpa+Course, data=df, FUN = sd)
post_data <- left_join(post_data,temp, by=c("grad_gpa", "Course"))
temp<- aggregate(cipstscr~grad_gpa+Course, data=df, FUN = IQR)
post_data <- left_join(post_data,temp, by=c("grad_gpa", "Course"))
colnames(post_data)<- c("Grade","Course","Mean_post","Median_post","SD_post","IQR_post")
post_data$div_iqr_post <- post_data$IQR/1.35
course_data<- left_join(course_data,post_data, by = c("Grade", "Course"))

```

```{r}
kable(course_data[,1:7], caption="Summary statistics for pre test scores")
kable(course_data[,c(1,2,8:12)], caption="Summary statistics for post test scores")
#kable(course_data, "html") %>% 
#  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

\newpage

## Linear relationship between mean or median, and grade. 

The following scatterplot plots summary statistics (median top row, mean bottom row) for pre test scores (right) and post test scores (left) as a function of grade.  **Legend: Red (1315), Green (1430), Blue (2425)**

```{r, fig.width=5, fig.height=4, fig.pos='H', fig.cap="Scatterplots of the means and medians versus course grades"}
DDD_mean<-ggplot(course_data, aes(x=Grade,y=Mean_pre,group=Course, color=Course))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE) + theme(legend.position="none")
DDD_median<-ggplot(course_data, aes(x=Grade,y=Median_pre,group=Course, color=Course))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE)+ theme(legend.position="none")

EEE_mean<-ggplot(course_data, aes(x=Grade,y=Mean_post,group=Course, color=Course))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE)+ theme(legend.position="none")
EEE_median<-ggplot(course_data, aes(x=Grade,y=Median_post,group=Course, color=Course))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE)+ theme(legend.position="none")

ggdraw() +
  draw_plot(DDD_mean, 0, 0, .5, .5) +
  draw_plot(DDD_median, 0, 0.5, .5, .5) +
  draw_plot(EEE_mean, 0.5, 0, .5, .5) +
  draw_plot(EEE_median, 0.5, 0.5, .5, .5) 
```

For the posttest, the linear relationship between median and grade is much stronger and there are far fewer outliers.

## Correlation between grade and test score. 
Linear model coefficients and spearman correlation values were calculated to quantify the strength of relationship between GPA and test score. 

#### Using individual student level data
These aren't the exact comparisons that I want to make but they are also nice for comparison so I am going to keep them in this preliminary work.
```{r}
library(plyr)
pre <- merge(
  ddply(df, .(Course), function(xx) coefficients(lm(ciprescr ~ grad_gpa, data=xx))), 
  ddply(df, .(Course), function(xx) return(data.frame(COR = cor(xx$grad_gpa, xx$ciprescr, use="complete.obs"))))
)

post <- merge(
  ddply(df, .(Course), function(xx) coefficients(lm(cipstscr ~ grad_gpa, data=xx))), 
  ddply(df, .(Course), function(xx) return(data.frame(COR = cor(xx$grad_gpa, xx$cipstscr, use="complete.obs"))))
)

kable(pre, caption="Summaries using full pre data")
kable(post, caption="Summaries using full post data")
```

#### Using class aggregated summary statistics
This bit of code looks at the correlations between grade and the mean or median test score (by grades) for each of the courses. It indicates that there is a very small positive relationship between pretest means and GPA but that there is a very strong positive relationship with posttest means.  
```{r}
mean.pre <- merge(
    ddply(course_data, .(Course), function(xx) coefficients(lm(Mean_pre ~ Grade, data=xx))),
    ddply(course_data, .(Course), function(xx) return(data.frame(COR = cor(xx$Mean_pre, xx$Grade, use="complete.obs"))))
)

mean.post <- merge(
  ddply(course_data, .(Course), function(xx) coefficients(lm(Mean_post ~ Grade, data=xx))),   
  ddply(course_data, .(Course), function(xx) return(data.frame(COR = cor(xx$Mean_post, xx$Grade, use="complete.obs"))))
)

med.pre <- merge(
  ddply(course_data, "Course", function(xx) coefficients(lm(Median_pre ~ Grade, data=xx))) , 
  ddply(course_data, .(Course), function(xx) return(data.frame(COR = cor(xx$Median_pre, xx$Grade, use="complete.obs"))))
)

med.post <- merge(
  ddply(course_data, "Course", function(xx) coefficients(lm(Median_post ~ Grade, data=xx))),
  ddply(course_data, .(Course), function(xx) return(data.frame(COR = cor(xx$Median_post, xx$Grade, use="complete.obs"))))   
)

kable(mean.pre, caption="Mean pre")
kable(mean.post, caption="Mean post")
kable(med.pre, caption="Median pre")
kable(med.post, caption="Median post")
```


# Creating simulated course data

Since the goal is to understand the effect missing data has on parameter estimation under varying and controlled missing data mechanisms, we used the trends seen in the historical data to generate simulated data using realistic parameters. 

In this section we develop three courses where only the post test intercept varies and a fourth course where the slope varies. 

I developed the first three courses to look at how the missing data impacts them differently when only the posttest intercept varies. I added the fourth one to get a sneak at what varying the slope does. We may want to include the slope in some future analysis.

```{r, echo=FALSE, eval=FALSE}
eq_course <- data.frame(c(1,2,3,4),c(25,25,25,25),c(2,2,2,2),c(25,43,58,43),c(6,6,6,10))
colnames(eq_course)<- c("Course","int_pre","slope_pre","int_post","slope_post")
print(eq_course)
#save(eq_course, file="~/Documents/Missing Data/course_equation_mean")
```

The next step in developing the models is to determine the relationship between standard deviation and means for the different groups of students. The first way that I want to do that is with the data that I already have that is broken down by grade for the three courses. This plot shows that there are slightly different relationships between mean and sd for pretests and posttests. However, I think that the analysis is flawed by how few data point there are and how the values are mostly rather low.   

```{r, echo=FALSE, eval=FALSE}
temp <- course_data[c(3,5)]
colnames(temp)<- c("mean","sd")
temp$time <-"pre"
temp1 <- course_data[c(6,8)]
colnames(temp1)<- c("mean","sd")
temp1$time <-"post"
temp <- rbind(temp,temp1)
ggplot(temp, aes(x=mean,y=sd,group=time, color=time))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE)
ggplot(temp, aes(x=mean,y=sd))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE,formula=y ~ poly(x, 3, raw=TRUE),colour="red")

model <- lm(sd ~ poly(mean,2),data=temp)
summary(model)
```

Now I also happen to have several much larger data sets with means and standard deviations for different classes.

```{r, eval=FALSE}
load("~/Documents/Missing Data/df_sd_mean")

temp<-na.exclude(df_sd_mean)
ggplot(temp, aes(x=mean,y=sd,group=time, color=time))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE,formula=y ~ poly(x, 2))
ggplot(temp, aes(x=mean,y=sd))+  
  geom_point()+  geom_smooth(method=lm, se=FALSE, fullrange=TRUE,formula=y ~ poly(x, 2, raw=TRUE),colour="red")

model <- lm(sd ~ poly(mean,2),data=temp, na.action = )
summary(model)
```
Next steps
Look at grade distributions and settle on 3 that I like.
Build courses with those grade distributions and see if the boxplots by grade look at all similar to those that i produced in the earlier analysis.
I should also add a figure for what the grades by score relationship looks like in the courses that I am building.

```{r, eval=FALSE}
library(reshape2)
load("grade_dist")
colnames(grade_dist)<- c("year","semester","course","enrollment","A","B","C","D","F","NC","I","IC","W","WU","DWF+D","DWF-D")
grade_dist <- grade_dist[!(grade_dist$A+grade_dist$B+grade_dist$C==0),]
grade_dist$id <- seq.int(nrow(grade_dist))

#Creates barplot of average
av_dist <- as.data.frame(colMeans(grade_dist[c(5:9,16)],na.rm = TRUE))
av_dist <- cbind(rownames(av_dist), data.frame(av_dist, row.names=NULL))
colnames(av_dist)<-c("variable","value")
ggplot(data=av_dist, aes(x=variable,y=value)) +
geom_bar(stat="identity")
av_dist_ave <- av_dist
```
This is pretty neat. It shows that there are two distinct types of high A courses. Courses with high As and Bs and courses with high As and Fs
```{r, eval=FALSE}

#Creates barplot of high A
temp <- grade_dist[grade_dist$id==186 |grade_dist$id==6 |grade_dist$id==79 |grade_dist$id==43 |grade_dist$id==109,]
temp <- temp[c(5:9,16,17)]
temp1 <- melt(temp, id.vars = c("id"),measure.vars = c("A","B","C","D","F","DWF-D"))
ggplot(data=temp1, aes(x=variable, y=value, fill=as.factor(id))) +
geom_bar(stat="identity", position = position_dodge())


#Creates barplots for courses with hiA and hi F
hiAhiF<- grade_dist[grade_dist$A>0.2&grade_dist$`DWF-D`>0.2,]
temp <- grade_dist[grade_dist$id %in% hiAhiF$id,]
temp <- temp[c(5:9,16,17)]
temp1 <- melt(temp, id.vars = c("id"),measure.vars = c("A","B","C","D","F","DWF-D"))
ggplot(data=temp1, aes(x=variable, y=value, fill=as.factor(id))) +
geom_bar(stat="identity", position = position_dodge())

#Creates barplot of average
av_dist <- as.data.frame(colMeans(hiAhiF[c(5:9,16)],na.rm = TRUE))
av_dist <- cbind(rownames(av_dist), data.frame(av_dist, row.names=NULL))
av_dist_hiAhiF <-av_dist
colnames(av_dist)<-c("variable","value")
ggplot(data=av_dist, aes(x=variable,y=value)) +
geom_bar(stat="identity")

#Creates barplots for courses with hiA and hi B
hiAhiB<- grade_dist[grade_dist$A>0.2&grade_dist$B>0.2&grade_dist$course!="NSCI 141",]
temp <- grade_dist[grade_dist$id %in% hiAhiB$id,]
temp <- temp[c(5:9,16,17)]
temp1 <- melt(temp, id.vars = c("id"),measure.vars = c("A","B","C","D","F","DWF-D"))
ggplot(data=temp1, aes(x=variable, y=value, fill=as.factor(id))) +
geom_bar(stat="identity", position = position_dodge())

#Creates barplot of average
av_dist <- as.data.frame(colMeans(hiAhiB[c(5:9,16)],na.rm = TRUE))
av_dist <- cbind(rownames(av_dist), data.frame(av_dist, row.names=NULL))
av_dist_hiA <-av_dist
colnames(av_dist)<-c("variable","value")
ggplot(data=av_dist, aes(x=variable,y=value)) +
geom_bar(stat="identity")
```

```{r, eval=FALSE}
#Creates barplots for courses with hi F
hiF<- grade_dist[grade_dist$A<0.1& grade_dist$`DWF-D`>0.3,]
temp <- grade_dist[grade_dist$id %in% hiF$id,]
temp <- temp[c(5:9,16,17)]
temp  <- temp[order(temp$B,decreasing=TRUE),]
temp$id <- seq.int(nrow(temp))
temp1 <- melt(temp, id.vars = c("id"),measure.vars = c("A","B","C","D","F","DWF-D"))
ggplot(data=temp1, aes(x=variable, y=value, fill=as.factor(id))) +
geom_bar(stat="identity", position = position_dodge())

#Creates barplots for courses with hi F hiB
hiFhiB<- grade_dist[grade_dist$A<0.1& grade_dist$`DWF-D`>0.3& grade_dist$B>0.2,]
temp <- grade_dist[grade_dist$id %in% hiFhiB$id,]
temp <- temp[c(5:9,16,17)]
temp1 <- melt(temp, id.vars = c("id"),measure.vars = c("A","B","C","D","F","DWF-D"))
ggplot(data=temp1, aes(x=variable, y=value, fill=as.factor(id))) +
geom_bar(stat="identity", position = position_dodge())

av_dist <- as.data.frame(colMeans(hiFhiB[c(5:9,16)],na.rm = TRUE))
av_dist <- cbind(rownames(av_dist), data.frame(av_dist, row.names=NULL))
colnames(av_dist)<-c("variable","value")
ggplot(data=av_dist, aes(x=variable,y=value)) +
geom_bar(stat="identity")

#Creates barplots for courses with hi F hiC
hiFhiC<- grade_dist[grade_dist$A<0.1& grade_dist$`DWF-D`>0.3& grade_dist$C>0.25,]
temp <- grade_dist[grade_dist$id %in% hiFhiC$id,]
temp <- temp[c(5:9,16,17)]
temp1 <- melt(temp, id.vars = c("id"),measure.vars = c("A","B","C","D","F","DWF-D"))
ggplot(data=temp1, aes(x=variable, y=value, fill=as.factor(id))) +
geom_bar(stat="identity", position = position_dodge())

av_dist <- as.data.frame(colMeans(hiFhiC[c(5:9,16)],na.rm = TRUE))
av_dist <- cbind(rownames(av_dist), data.frame(av_dist, row.names=NULL))
av_dist_hiF <-av_dist
colnames(av_dist)<-c("variable","value")
ggplot(data=av_dist, aes(x=variable,y=value)) +
geom_bar(stat="identity")
```

```{r, eval=FALSE}
colnames(av_dist_hiA)<- c("variable","value_one")
colnames(av_dist_hiF)<- c("variable","value_two")
dists <- left_join(av_dist_ave,av_dist_hiA)
dists <- left_join(dists,av_dist_hiF)
colnames(dists)<- c("grade","ave","high","low")

temp1 <- melt(dists)
ggplot(data=temp1, aes(x=grade, y=value, fill=as.factor(variable))) +
geom_bar(stat="identity", position = position_dodge())+ggtitle("Grade distributions to use in the study")

colSums(dists[c(1:4,6),c(2:4)])

```

```{r, eval=FALSE}
dists <- dists[c(1:4,6),]
dists$grade <- as.factor(c(4,3,2,1,0))
temp1 <- melt(dists, measure.vars = c("ave","high","low"))
ggplot(data=temp1, aes(x=grade, y=value, fill=as.factor(variable))) +
geom_bar(stat="identity", position = position_dodge())+ggtitle("Grade distributions to use in the study")

colSums(dists[,c(2:4)])
save(dists, file="~/Documents/Missing Data/grade_distributions")

```

The following section of code starts building the simulated class data. I can imagine moving it into its own chunk of code in the future, and I am going to write it with that in mind.

This chunk establishes the equations and data frames that will be drawn on to generate the data. 
The linear equations between course grade and pretest and posttest scores for the four different courses.
The quadratic equation between mean test score and standard deviation.
The participation rates.
The three grade distributions
```{r, eval=FALSE}
#Grade distributions. I changed this s that the df is written in the code rather than loaded.
dists <- data.frame(c(4,3,2,1,0),c(0.15,0.25,0.32,0.08,0.17),c(0.25,0.31,0.26,0.06,0.09),c(0.05,0.15,0.35,0.08,0.36))
colnames(dists) <- c("grade","ave","high","low")

# scores by grade
load("~/Documents/Missing Data/course_equation_mean")
#standard deviation sd=-33.2*x^2+14.6x+16.6
sd_eq<-function(x){
  if (x <1 ) print("x should be in percent and range from 0 to 100")
  if (x < 0) stop("'x' must be >= 1")
  if (x > 100) stop("'x' must be <= 100")
  -33.2*(x/100)^2+14.6*(x/100)+16.6}
#Participation rates I haven't made these into an R file yet. Currently they are a csv file.
#load()
```

I am generating the datasets using the rtnorm function. The rtnorm function returns a normal distribution of data that is truncated by a set of boundaries. This truncation allows me to limit the scores to be between 0 and 100. The normal distribution isn't quite right because there are often outliers on the scores but it is a close approximation and aligns with the assumptions for how the data is normally analyzed. 

I will generate the pretest scores and the posttest scores separately. Initially, I wanted to generate the pretest scores and a gain value. Then I would have calculated the post test by adding these two values. This did not work because it generated a large amount of data that fell outside of [0,100]. The advantage of that approach is that it ties the pre and posttest together. So I would expect the correlations within those data sets (pre/post) to be more realistic. Since the analyses that I want to run are all based on the means of the groups I don't need to worry about the relationships between pre and post. It may be an issue if I want to run a matched T-test or get an matched effect size.

```{r, eval=FALSE}
library(msm)

#this is a list of the dfs that are loaded as part of this code chunk
##dists
##eq_course
##sd_eq
##part_rat this isn't in here but it is the participation rate data


C <- 1000 # this is the total class size
K <- 100 #Number of courses
G <- 2 #this is the grade distribution to use it varies from 2 to 4 with 2=ave, 3=high, 4=low
R <- 1 #missing rate it varies from 1 to 5
P <- 2 #This is the courses performance from the generator seed from 1:4

#Makes a data frame to fill in the subsequent steps. This data frame is deleted.
#grade is stored in the dists[grade,% of that grade]
A_n <-round(C*dists[1,G],0)
A_mean <- eq_course[P,2]+dists[1,1]*eq_course[P,3] #this just calculates the mean value for this grade and course
A_sd <- sd_eq(A_mean)
  full<-as.data.frame(rtnorm(A_n,A_mean,A_sd,0,100))
  colnames(full)<- "pre"
B_mean <- eq_course[P,4]+dists[1,1]*eq_course[P,5] #this just calculates the mean value for this grade and course
B_sd <- sd_eq(B_mean)  
  full$post <- rtnorm(A_n,B_mean,B_sd,0,100)
  full$grade <- dists[1,1] #inputs grade for this chunk of data
  full$P <- P #inputs the performance group for this chunk of data (P)
  full$G <- G
  full$R <- R
  full$iteration <- "x"
  
for(i in 1:5){
  A_n <-round(C*dists[i,G],0)
A_mean <- eq_course[P,2]+dists[i,1]*eq_course[P,3] #this just calculates the mean value for this grade and course
A_sd <- sd_eq(A_mean)
  temp<-as.data.frame(rtnorm(A_n,A_mean,A_sd,0,100))
  colnames(temp)<- "pre"
B_mean <- eq_course[P,4]+dists[i,1]*eq_course[P,5] #this just calculates the mean value for this grade and course
B_sd <- sd_eq(B_mean)  
  temp$post <- rtnorm(A_n,B_mean,B_sd,0,100)
  temp$grade <- dists[i,1] #inputs grade for this chunk of data
  temp$P <- P #inputs the performance group for this chunk of data (P)
  temp$G <- G
  temp$R <- R
  temp$iteration <- "j"
  full<- rbind(full,temp)
}  
full <- full[!(full$iteration=="x"),]

temp <- full[c(3,1)]
colnames(temp) <-c("Grade","Pretest")
temp$Grade<- as.factor(temp$Grade)
med_pre <- ggplot(temp, aes(x=Grade,y=Pretest)) + 
  geom_boxplot()+ 
  scale_y_continuous(name = "Pretest (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") 

temp <- full[c(3,2)]
colnames(temp) <-c("Grade","Posttest")
temp$Grade<- as.factor(temp$Grade)
med_post <- ggplot(temp, aes(x=Grade,y=Posttest)) + 
  geom_boxplot()+
  scale_y_continuous(name = "Posttest (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") 

C <- 1000 # this is the total class size
K <- 100 #Number of courses
G <- 2 #this is the grade distribution to use it varies from 2 to 4 with 2=ave, 3=high, 4=low
R <- 1 #missing rate it varies from 1 to 5
P <- 4 #This is the courses performance from the generator seed from 1:4

#Makes a data frame to fill in the subsequent steps. This data frame is deleted.
#grade is stored in the dists[grade,% of that grade]
A_n <-round(C*dists[1,G],0)
A_mean <- eq_course[P,2]+dists[1,1]*eq_course[P,3] #this just calculates the mean value for this grade and course
A_sd <- sd_eq(A_mean)
  full<-as.data.frame(rtnorm(A_n,A_mean,A_sd,0,100))
  colnames(full)<- "pre"
B_mean <- eq_course[P,4]+dists[1,1]*eq_course[P,5] #this just calculates the mean value for this grade and course
B_sd <- sd_eq(B_mean)  
  full$post <- rtnorm(A_n,B_mean,B_sd,0,100)
  full$grade <- dists[1,1] #inputs grade for this chunk of data
  full$P <- P #inputs the performance group for this chunk of data (P)
  full$G <- G
  full$R <- R
  full$iteration <- "x"
  
for(i in 1:5){
  A_n <-round(C*dists[i,G],0)
A_mean <- eq_course[P,2]+dists[i,1]*eq_course[P,3] #this just calculates the mean value for this grade and course
A_sd <- sd_eq(A_mean)
  temp<-as.data.frame(rtnorm(A_n,A_mean,A_sd,0,100))
  colnames(temp)<- "pre"
B_mean <- eq_course[P,4]+dists[i,1]*eq_course[P,5] #this just calculates the mean value for this grade and course
B_sd <- sd_eq(B_mean)  
  temp$post <- rtnorm(A_n,B_mean,B_sd,0,100)
  temp$grade <- dists[i,1] #inputs grade for this chunk of data
  temp$P <- P #inputs the performance group for this chunk of data (P)
  temp$G <- G
  temp$R <- R
  temp$iteration <- "j"
  full<- rbind(full,temp)
}  
full <- full[!(full$iteration=="x"),]

temp <- full[c(3,1)]
colnames(temp) <-c("Grade","Pretest")
temp$Grade<- as.factor(temp$Grade)
low_pre <- ggplot(temp, aes(x=Grade,y=Pretest)) + 
  geom_boxplot()+ 
  scale_y_continuous(name = "Pretest (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") 

temp <- full[c(3,2)]
colnames(temp) <-c("Grade","Posttest")
temp$Grade<- as.factor(temp$Grade)
low_post <- ggplot(temp, aes(x=Grade,y=Posttest)) + 
  geom_boxplot()+
  scale_y_continuous(name = "Posttest (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") 

C <- 1000 # this is the total class size
K <- 100 #Number of courses
G <- 2 #this is the grade distribution to use it varies from 2 to 4 with 2=ave, 3=high, 4=low
R <- 1 #missing rate it varies from 1 to 5
P <- 3 #This is the courses performance from the generator seed from 1:4

#Makes a data frame to fill in the subsequent steps. This data frame is deleted.
#grade is stored in the dists[grade,% of that grade]
A_n <-round(C*dists[1,G],0)
A_mean <- eq_course[P,2]+dists[1,1]*eq_course[P,3] #this just calculates the mean value for this grade and course
A_sd <- sd_eq(A_mean)
  full<-as.data.frame(rtnorm(A_n,A_mean,A_sd,0,100))
  colnames(full)<- "pre"
B_mean <- eq_course[P,4]+dists[1,1]*eq_course[P,5] #this just calculates the mean value for this grade and course
B_sd <- sd_eq(B_mean)  
  full$post <- rtnorm(A_n,B_mean,B_sd,0,100)
  full$grade <- dists[1,1] #inputs grade for this chunk of data
  full$P <- P #inputs the performance group for this chunk of data (P)
  full$G <- G
  full$R <- R
  full$iteration <- "x"
  
for(i in 1:5){
  A_n <-round(C*dists[i,G],0)
A_mean <- eq_course[P,2]+dists[i,1]*eq_course[P,3] #this just calculates the mean value for this grade and course
A_sd <- sd_eq(A_mean)
  temp<-as.data.frame(rtnorm(A_n,A_mean,A_sd,0,100))
  colnames(temp)<- "pre"
B_mean <- eq_course[P,4]+dists[i,1]*eq_course[P,5] #this just calculates the mean value for this grade and course
B_sd <- sd_eq(B_mean)  
  temp$post <- rtnorm(A_n,B_mean,B_sd,0,100)
  temp$grade <- dists[i,1] #inputs grade for this chunk of data
  temp$P <- P #inputs the performance group for this chunk of data (P)
  temp$G <- G
  temp$R <- R
  temp$iteration <- "j"
  full<- rbind(full,temp)
}  
full <- full[!(full$iteration=="x"),]

temp <- full[c(3,1)]
colnames(temp) <-c("Grade","Pretest")
temp$Grade<- as.factor(temp$Grade)
high_pre <- ggplot(temp, aes(x=Grade,y=Pretest)) + 
  geom_boxplot()+ 
  scale_y_continuous(name = "Pretest (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") 

temp <- full[c(3,2)]
colnames(temp) <-c("Grade","Posttest")
temp$Grade<- as.factor(temp$Grade)
high_post <- ggplot(temp, aes(x=Grade,y=Posttest)) + 
  geom_boxplot()+
  scale_y_continuous(name = "Posttest (%)", limits = c(0,100))+
  scale_x_discrete(name = "Grade") 
 
sim_plots <- ggdraw() +
  draw_plot(low_post, 0, 0, .33, .5) +
  draw_plot(med_post, 0.33, 0, .33, .5) +
  draw_plot(high_post, 0.66, 0, .33, .5) +
  draw_plot(low_pre, 0, .5, .33, .5) +
  draw_plot(med_pre, 0.33, 0.5, .33, .5) +
  draw_plot(high_pre, 0.66, 0.5, .33, .5) 

```

```{r, eval=FALSE}
print("For a course with average grade distribution")
plot(sim_plots)
```





```{r, eval=FALSE}
#This is old code that I wa using to write the data generator code.
for(j in 1:K){
  for(i in 1:5){
    temp<-as.data.frame(rtnorm(C*grade_dist[L,i+1],as.numeric(seed[i+P*5-5,3]),as.numeric(seed[i+P*5-5,5]),0,100))
    colnames(temp)<- "pre"
    temp$post <- rtnorm(C*grade_dist[L,i+1],as.numeric(seed[i+P*5-5,4])+as.numeric(seed[i+P*5-5,3]),as.numeric(seed[i,6]),0,100)
    temp$grade <- as.numeric(seed[i,2])
    temp$group <- as.numeric(seed[i,1])
    temp$iteration <- j
    full <- rbind(full,temp)
  }
}
full <- full[!(full$iteration=="x"),] #removes data that started the dataframe


```

```{r}
#this is a list of the dfs that are loaded as part of this code chunk
##dists
##eq_course
##sd_eq
##part_rat this isn't in here but it is the participation rate data

dists <- data.frame(c(4,3,2,1,0),c(0.15,0.25,0.32,0.08,0.17),c(0.25,0.31,0.26,0.06,0.09),c(0.05,0.15,0.35,0.08,0.36))
colnames(dists) <- c("grade","ave","high","low")

eq_course <- data.frame(c(1,2,3,4),c(25,25,25,25),c(2,2,2,2),c(25,43,58,43),c(6,6,6,10))
colnames(eq_course)<- c("Course","int_pre","slope_pre","int_post","slope_post")

sd_eq<-function(x){
  if (x <1 ) print("x should be in percent and range from 0 to 100")
  if (x < 0) stop("'x' must be >= 1")
  if (x > 100) stop("'x' must be <= 100")
  -33.2*(x/100)^2+14.6*(x/100)+16.6}

part_rat <- data.frame(c(0,1,2,3,4),c(0.01,0.02,0.05,0.13,0.30),c(0.02,0.05,0.18,0.45,0.75),c(0.04,0.17,0.49,0.82,0.96),c(0.10,0.41,0.81,0.96,0.99),c(0.24,0.71,0.95,0.99,1.00))
colnames(part_rat)<- c("grade","zero","one","two","three","four")
```

#Overall participation rates for the 3 grade distributions and 5 participation rates

```{r}
dists <- dists[order(dists$grade),]
part_rat <- part_rat[order(part_rat$grade),]
total_part <- dists
total_part$N_tot_ave <- round(1000*total_part$ave,0)
total_part$ave_zero <- round(total_part$N_tot_ave*part_rat$zero,0)
total_part$ave_one <- round(total_part$N_tot_ave*part_rat$one,0)
total_part$ave_two <- round(total_part$N_tot_ave*part_rat$two,0)
total_part$ave_three <- round(total_part$N_tot_ave*part_rat$three,0)
total_part$ave_four <- round(total_part$N_tot_ave*part_rat$four,0)

total_part$N_tot_high <- round(1000*total_part$high,0)
total_part$high_zero <- round(total_part$N_tot_high*part_rat$zero,0)
total_part$high_one <- round(total_part$N_tot_high*part_rat$one,0)
total_part$high_two <- round(total_part$N_tot_high*part_rat$two,0)
total_part$high_three <- round(total_part$N_tot_high*part_rat$three,0)
total_part$high_four <- round(total_part$N_tot_high*part_rat$four,0)

total_part$N_tot_low <- round(1000*total_part$low,0)
total_part$low_zero <- round(total_part$N_tot_low*part_rat$zero,0)
total_part$low_one <- round(total_part$N_tot_low*part_rat$one,0)
total_part$low_two <- round(total_part$N_tot_low*part_rat$two,0)
total_part$low_three <- round(total_part$N_tot_low*part_rat$three,0)
total_part$low_four <- round(total_part$N_tot_low*part_rat$four,0)

aa <- colSums(total_part[c(6:10)])/colSums(total_part[5])
bb <- colSums(total_part[c(12:16)])/colSums(total_part[11])
cc <- colSums(total_part[c(18:22)])/colSums(total_part[17])
ee <- c(0,1,2,3,4)
ff <- c("ave","ave","ave","ave","ave")
gg <- c("high","high","high","high","high")
hh <- c("low","low","low","low","low")
thing <- data.frame(ee,aa,ff)
colnames(thing)<- c("Participation","Value","Grade_Distributions")
thing1 <- data.frame(ee,bb,gg)
colnames(thing1)<- c("Participation","Value","Grade_Distributions")
thing2 <- data.frame(ee,cc,hh)
colnames(thing2)<- c("Participation","Value","Grade_Distributions")
thing <- rbind(thing,thing1,thing2)

ggplot(data=thing, aes(x=Participation,y=Value)) +
geom_bar(stat="identity", aes(fill=Grade_Distributions), position = position_dodge())+ggtitle("Total Participation Rates by Grade Distribution and Participation Rate")

```